{
    "collab_server" : "",
    "contents" : "require(bbmle)  # required packages\nrequire(deSolve)\nlibrary(zoo)\nlibrary(beepr)\n\n#****************Required R scripts*************\nsource(\"r_1_data_bioassay.R\")                   # count and climate data      \n\nsource(\"r_2_subfuncs_adult_mortality.R\")        # initial estimates for adult temperature-dependent mortality from fitting to the mark-release recapture data\n\nsource(\"r_2_subfuncs_pupal_mortality.R\")        # initial estimates for pupal temperature-dependent mortality from fitting to the laboratory data\n\nsource(\"r_3_fit_funcs.R\")                       # likelihood function\n#***********************************************\n\n#********************Model parameters and conditions*************************************\ntemps <- b.temps$MeanC # temperature data for each day\nlength(temps) \n\ntimes <- seq(from = 1, to = length(temps),by=1)        # time steps to solve model at (in days)\n\ntsetse_params <- function(   larv = 1/10            ## rate larvae are produced (days)\n                             , pup.a = 17.94        ## rate pupae emerge as adults (days) - if not temperature dependent\n                             , pup.b = 82.3\n                             , pup.c = -0.253\n                             , pup.t1 = 16\n                             , nboxes=3\n                             , mud.p = 0.0000       ## pupal density-dependent mortality\n                             , mu.p.k1 = pk1        ## parameters for pupal temperature-dependent mortality\n                             , mu.p.k2 = pk2\n                             , mu.p.k3 = pk3\n                             , mu.p.k4 = pk4\n                             , mu.a.k1 = mu.a.k1.fit          ## parameter 1 adult temperature-dependent mortality\n                             , mu.a.k2 = mu.a.k2.fit          ## parameter 2 adult temperature-dependent mortality\n                             , adults.zero = 300    ## numbers of adults at start\n                             , pupae.zero = 300*nboxes     ## numbers of pupae at start\n)\n  return(as.list(environment()))\n\n# Initial conditions. A vector containing the numbers of starting pupae P and adults A.\ninitial <- c( P=tsetse_params()$pupae.zero/tsetse_params()$nboxes \n              ,rep(tsetse_params()$pupae.zero/tsetse_params()$nboxes,tsetse_params()$nboxes-1)\n              ,A=tsetse_params()$adults.zero\n) \n\n#******************************************************************************\ndays.pupal.period <- sapply(times,function(x){\n  day <- x                                                    # time t in the model\n  temp <- temps[x]\n  store.days <- 1  \n  # store the total pupal duration\n  cum.rate <- 17.94 + 82.3*exp(-0.253*(temp-16))  # start off with the rate of pupal development for that day\n  temperature <- numeric(0)  \n  total.days <- numeric(0)\n  temperature[1] <- temp                                     # first value is temperature at day tt\n  while (cum.rate < 1) {\n    store.days <- store.days + 1                             # update store.days\n    day <- day - 1                                           # look at previous day\n    if ( day <= 0 ) {                                        # if before model start assign to 25 - running model for a year before the actual data means this doesn't matter\n      day.temp <- 25\n    }else{\n      day.temp <- temps[day]                                  # otherwise set next temp to previous days temp\n    }                    \n    temperature[store.days] <- day.temp                       # store in vector of temperatures\n    total.days[store.days] <- store.days\n    cum.rate <- cum.rate + 17.94 + 82.3*exp(-0.253*(temp-16))  # increase development\n  }\n                     # now calculate mean for that period for input into pupal survival as function of temperature\n  return(total.days[length(total.days)])\n})\n#***************Calcluate look-up table for pupal probability of survival****\n# calculate how far back to go to average temperature for proportion of pupae surviving\n# mean.temp.pup.period <- sapply(times,function(x){\n#   day <- x                                                    # time t in the model\n#   temp <- temps[x]\n#   store.days <- 1  \n#   # store the total pupal duration\n#   cum.rate <- 17.94 + 82.3*exp(-0.253*16)  # start off with the rate of pupal development for that day\n#   temperature <- numeric(0)                                   # empty vector to store temperatures\n#   temperature[1] <- temp                                      # first value is temperature at day tt\n#   while (cum.rate < 1) {\n#     store.days <- store.days + 1                              # update store.days\n#     day <- day - 1                                            # look at previous day\n#     if ( day <= 0 ) {                                         # if before model start assign to 25 - running model for a year before the actual data means this doesn't matter\n#       day.temp <- 25\n#     }else{\n#       day.temp <- temps[day]                                  # otherwise set next temp to previous days temp\n#     }                    \n#     temperature[store.days] <- day.temp                       # store in vector of temperatures\n#     cum.rate <- cum.rate + 17.94 + 82.3*exp(-0.253*16)   # increase development\n#     total.days[x] <- store.days\n#   }\n#   num.days <- total.days                       # now calculate mean for that period for input into pupal survival as function of temperature\n#   return(num.days)\n# })\n#***********************************************************************\n\n#********************Population dynamics model***********************************\ntsetse_mod <- function(tt,yy,parms) with(c(parms,as.list(yy)), {\n  \n  temp <-  temps[tt]                                          # the temperature data is read in by another script. This takes the temperature for the time point in the model (tt)\n  \n  pup <- (1/(pup.a + pup.b*exp(pup.c*(temp-pup.t1))))/nboxes  # pupal development rate for day tt\n  \n  mean.temp <- mean.temp.pup.period[tt]                       # now calculate mean for that period for input into pupal survival as function of temperature\n\n  inst.mort.pup <- mort_func(k1=mu.p.k1                       # calculate pupal mortality rate at the given temperature\n                             ,k2=mu.p.k2\n                             ,k3=mu.p.k3\n                             ,k4=mu.p.k4\n                             ,temp=mean.temp)                 # note using the above mean.temp here\n  \n  prob.surv.pup <- exp(-inst.mort.pup)                        # convert to a probability\n  \n  if (temp > 24){                                             # calculate adult temperature-dependent mortality\n    mu.at <- mu.a.k1*exp(mu.a.k2*(temp-24))\n  }else{\n    mu.at <- mu.a.k1\n  }\n\n  # ODEs\n  deriv <- rep(NA,length(yy)) # creating an empty vector to store ODEs in here\n  \n  deriv[-(nboxes+1)] <- - (mud.p*sum(yy[-(nboxes+1)]))*yy[-(nboxes+1)] - pup*yy[-(nboxes+1)] # all compartments rate at which they leave nboxes subcompartments of the pupal stage\n  \n  deriv[1] <-  deriv[1] + larv*A  # rate at which pupae enter first subcompartment\n  \n  deriv[2:nboxes] <- deriv[2:nboxes] + pup*yy[-c(nboxes,nboxes+1)] # rate at which pupae enter other compartments\n  \n  deriv[nboxes+1] <-  yy[length(yy)-1]*pup/2*(prob.surv.pup) - mu.at*A  # change in adults \n  \n  return(list(deriv))\n  \n  \n})\n#*******************************************************\n\n#**************FUNCTION TO SIMULATE***************************************\nsimPop <- function(init=initial, tseq = times, modFunction=tsetse_mod      # function which runs the model\n                   , parms = tsetse_params()) { \n  simDat <- as.data.frame(lsoda(init, tseq, modFunction, parms=parms))\n  return(simDat)\n}\n########################################################\n\n#*********test run and plot**************\nstart_time <- Sys.time()\n#*****TEST**************\ntest <- simPop(parms=tsetse_params(mud.p=0.0000005))\n#**********************\nend_time <- Sys.time()\nend_time - start_time\n\n\ntest$yearmon <- b.temps$yearmon\ntest<-test[1831:22946,]\ntest2 <- ddply(test,.(yearmon),summarise,mean.cnt=mean(A))\n\nplot(count.times$yearmon\n     ,count.times$counts\n     ,log=\"y\"\n     ,xlim=c(as.yearqtr('1959 Q4'),\n               as.yearqtr('2017 Q4'))\n     ,ylim=c(0.1,100)\n     ,bty=\"n\"\n)\npar(new=T)\nplot(test2$yearmon\n     ,test2$mean.cnt\n     ,log=\"y\"\n     ,ylim=c(0.1,100)\n     ,bty=\"n\"\n     ,type=\"l\"\n     ,xlab=\"\"\n     ,ylab=\"\")\nbeep(sound=2)\n\nplot(b.temps$Date[1831:22946]\n     ,log10(test$A[1831:22946])\n     ,bty=\"n\"\n     ,type=\"l\"\n     ,xlab=\"Date\"\n     ,ylab=\"Numbers of adult tsetse\")\n\n# # #************initial parameters**********************\n# #**********First just fit density-dependent adult mortality***************\n init.pars <- c(\n    log_mud.p=log(0.0000005)\n    ,log_mu.a.k1=log(mu.a.k1.fit)\n    ,log_mu.a.k2=log(mu.a.k2.fit)\n )\n \n init.pars <- c(\n   log_mud.p=log(0.0000003)\n   ,log_mu.p.k2=log(pk2)\n   ,log_mu.p.k4=log(pk4)\n )\n# \n# #**************Optimise*******************************************\n trace <- 3\n start_time <- Sys.time()\n optim.vals <- optim(par = init.pars\n                     , objFXN\n                     , fixed.params = tsetse_params()\n                     , dat = count.times\n                     , control = list(trace = trace, maxit = 200)\n                     , method = \"SANN\")\n exp(optim.vals$par) \n end_time <- Sys.time()\n end_time - start_time\n beep(sound=2)\n \n optim.vals <- optim(par = optim.vals$par\n                     , objFXN\n                     , fixed.params = tsetse_params()\n                     , dat = count.times\n                     , control = list(trace = trace, maxit = 200)\n                     , method = \"SANN\")\n exp(optim.vals$par) # \n# \ninit.pars <- c(\n log_mud.p=log(0.000000641)\n ,log_mu.p.k2=log(2.239)\n ,log_mu.p.k4=log(1.222)\n)\n\ntest <- simPop(parms=tsetse_params(mud.p=0.000000641,mu.p.k2=2.239,mu.p.k4=1.222))\n\n# # want to then feed output from SANN to Nelder-Mead\n start_time <- Sys.time()\n optim.vals <- optim(par = init.pars #optim.vals$par#optim.vals$par\n                     , objFXN\n                     , fixed.params = tsetse_params()\n                     , dat = count.times\n                     , control = list(trace = trace, maxit = 1000, reltol = 10^-7)\n                     , method = \"Nelder-Mead\" # \n                     , hessian = T)\n optim.vals # convergence 0 means algorithm converged\n end_time <- Sys.time()\n end_time - start_time\n beep(sound=2)\n MLEfits <- optim.vals$par \n exp(MLEfits)\n# #******************************************************************\n\n# #*****************confidence intervals for parameter estimates*********\n fisherInfMatrix <- solve(optim.vals$hessian) ## invert the Hessian, to estimate the covar-var matrix of parameter estimates\n fisherInfMatrix\n# \n# # Finds the critical z value\n conf.level <- 0.95\n crit <- qnorm((1 + conf.level)/2)\n# \n ci <- optim.vals$par[1] + c(-1, 1) * crit * sqrt(abs(fisherInfMatrix[1, 1]))\n exp(ci)\n ci <- optim.vals$par[2] + c(-1, 1) * crit * sqrt(abs(fisherInfMatrix[2, 2]))\n exp(ci)\n ci <- optim.vals$par[3] + c(-1, 1) * crit * sqrt(abs(fisherInfMatrix[3,3]))\n exp(ci)\n ci <- optim.vals$par[4] + c(-1, 1) * crit * sqrt(abs(fisherInfMatrix[4, 4]))\n exp(ci)\n# \n ci <- optim.vals$par[5] + c(-1, 1) * crit * sqrt(abs(fisherInfMatrix[5, 5]))\n exp(ci)\n# \n# #**********************************************************************\n# \n# \n# # #********************************************************************\n test <- simPop(parms=tsetse_params( mu.a.k1=exp(MLEfits[2])\n                                    ,mu.a.k2=exp(MLEfits[3])\n                                    ,mud.p=exp(MLEfits[1])\n ))\n# # #********************************************************************\n\n\n#****************Plots************************************************\n#tiff(\"Fig_2.tiff\", height = 3, width = 5, units = 'in', compression=\"lzw\", res=400)\n# par(mar=c(3,3,1,1),mgp=c(2,1,0),cex=0.5)\n# plot( \n#       temps.count$time[65:length(temps.count$temp)]\n#       ,temps.count$count[65:length(temps.count$temp)]\n#      ,col=\"black\"\n#      ,cex.lab=1.2\n#      ,type=\"n\"\n#      ,bty=\"n\"\n#      ,xlab=\"Date\"\n#      ,xlim=c(as.yearqtr('1959 Q4'),\n#              as.yearqtr('2017 Q4'))\n#     # ,xlim=c(as.yearqtr('1990 Q4'),\n#      #        as.yearqtr('2017 Q4'))\n#     ,log=\"y\"\n#      ,pch=1\n#      ,ylab=\"Numbers of tsetse\"\n#      ,ylim=c(0.1,100)#,ylim=c(0.1,150)\n# )\n# points(temps.count$time[65:length(temps.count$temp)]\n#        ,temps.count$count[65:length(temps.count$temp)]\n#        ,cex=0.6\n#        ,col=\"red\"\n#        ,pch=19)\n# par(new=T)\n# plot(temps.count$time[65:length(test$A)]\n#      #,model.output\n#      ,test$A[65:length(test$A)]\n#      ,cex.lab=1.2\n#      ,type=\"l\"\n#      ,col=\"black\"\n#      ,bty=\"n\"\n#      ,xaxt=\"n\"\n#      ,yaxt=\"n\"\n#       ,xlim=c(as.yearqtr('1959 Q4'),\n#               as.yearqtr('2017 Q4'))\n#     # ,xlim=c(as.yearqtr('1990 Q4'),\n#    #          as.yearqtr('2017 Q4'))\n#     ,log=\"y\"\n#      ,xlab=\" \"\n#      ,ylab=\" \"\n#      ,lty=1\n#     ,ylim=c(0.1,100)\n#    # ,ylim=c(0.1,150)\n# )\n# \n# \n# legend(\"topright\",title=\"Numbers of tsetse\",legend=c(\"Observed\",\"Model\")\n#        ,lty=c(NA,1,3),pch=c(19,NA),col=c(\"red\",\"black\"),bty=\"n\")\n#dev.off()\n#********************************************************************************\n\n# \n# \n# temps <- rep(25,length(1:length(temps.count$temp)))         # temperature data for each month\n# \n# #***************run model with fitted parameters*********************\n# test <- simPop(parms=tsetse_params(mu.p.k1=exp(MLEfits[1])\n#                                    ,mu.p.k2=exp(MLEfits[2])\n#                                    ,mu.p.k3=exp(MLEfits[3])\n#                                    ,mu.p.k4=exp(MLEfits[4])\n#                                    ,mu.a.k1=exp(MLEfits[5])\n#                                    ,mu.a.k2=exp(MLEfits[6])\n#                                    ,mud.p=exp(MLEfits[7])\n# ))\n# \n# plot(temps.count$time[1:length(temps.count$temp)]\n#      #,model.output\n#      ,test$A\n#      #,test.smooth\n#      ,type=\"l\"\n#      ,col=\"black\"\n#      ,bty=\"n\"\n#      ,xaxt=\"n\"\n#      ,yaxt=\"n\"\n#      ,xlim=c(as.yearqtr('1950 q1'),\n#              as.yearqtr('2017 Q4'))\n#      #,log=\"y\"\n#      ,xlab=\" \"\n#      ,ylab=\" \"\n#      ,lty=3\n#      ,ylim=c(0.1,500)\n# )\n# \n# \n# \n",
    "created" : 1528204027215.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1743765598",
    "id" : "9E3CCF03",
    "lastKnownWriteTime" : 1528292308,
    "last_content_update" : 1528292308703,
    "path" : "~/GitHub/tsetse_climate_change/r_4_tsetsemod.R",
    "project_path" : "r_4_tsetsemod.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}